from AstTree import Node
from AstTree import ASTree

COMPILER VeKrestKrest

IGNORECASE
CHARACTERS
letter                         = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
digit                          = "0123456789".
cr                             = '\r'.
lf                             = '\n'.
tab                            = '\t'.
strings                        = CHR(32) .. CHR(255) - '"'.
 
TOKENS
identifier                     = letter {letter | digit | "_"}.
number                         = digit {digit} .
string                         = '"' { strings } '"' .
 
IGNORE cr + lf + tab

PRODUCTIONS
  VeKrestKrest<out tree>       = (. main_tree = Node(t='body') .) 
                                 { Defenition<out def_tree> (. main_tree.AddChild(def_tree) .)} 
                                 (. 
                                    tree = ASTree()
                                    tree.AddNode(main_tree)
                                    tree.PrintTree()
                                 .).

  Defenition<out defTree>      = identifier (. name = self.token.val .) 
                                 Params<out params> "->" Type<out type>
                                 FunctionDefinition<out tree> 
                                 (. 
                                    defTree = Node(value=f'{name}({params})->{type}', t='decl')
                                    tree.Rename('body')
                                    defTree.AddChild(tree)
                                 .).

  Params<out params>           = (. params = '' .)
                                 "(" [ FormalParamList<out fparams> (. params += fparams .) ] ")" .

  FormalParamList<out fparams> = (. fparams = '' .) FormalParameter<out fp> (. fparams += fp .) 
                                 {"," FormalParameter<out fp> (. fparams += ', ' + fp .)} .

  FunctionDefinition<out tree> = CompoundStatement<out tree> .
  FormalParameter<out fp>      = (. fp = '' .) Type<out type> (. fp = self.token.val .) identifier (. fp += ' ' + self.token.val .) .

  Type<out type>               = (. type = '' .)  
                                   "CELINA" (. type = self.token.val .) [ "["ConstExpression"]" ] 
                                 | "BUKVI"  (. type = self.token.val .)
                                 | "DROB"   (. type = self.token.val .) [ "["ConstExpression"]" ]
                                 | "PRAVDA" (. type = self.token.val .) [ "["ConstExpression"]" ].
  
  Statement<out tree>          = (. tree = Node(t='stat') .) 
                                 ( AssignmentExpression<out assigm_tree> (. tree = assigm_tree .)
                                 | CompoundStatement<out cmpd_tree> (. tree = cmpd_tree .) 
                                 | IfStatement<out if_tree> (. tree = if_tree .)
                                 | ReturnStatement<out ret_tree> (. tree.Rename("VOZDAT"); tree.AddChild(ret_tree) .) 
                                 | WhileStatement<out while_tree> (.  tree = while_tree .) ) .

  DeclrationOrStatement<out t> = (. t = Node() .)
                                 ( LocalDeclaration<out declar_tree> (. t = declar_tree .) 
                                 | Statement<out stat_tree> (. t = stat_tree .) ) .

  CompoundStatement<out tree>  = (. tree = Node(t='body') .)
                                 "{" {DeclrationOrStatement<out t> (. tree.AddChild(t) .)} "}" .

  LocalDeclaration<out tree>   = Type<out type> identifier 
                                 (. name = type + " " + self.token.val ; tree = Node(value=name, t='decl') .)
                                 ( "(" [ FormalParamList<out fparams> ] ")" (.  .)
                                 | "=" Expression<out expr_tree>    
                                 (.
                                    tree.Rename(name + ' =')
                                    tree.AddChild(expr_tree)
                                 .) ) ";" .

  ConstExpression              = Expression<out tree> .
  Expression<out tree>         = Conditional<out cond_tree> (. tree = cond_tree .)
                                 { AssignmentOperator<out op> Expression<out expr_tree> 
                                 (. 
                                    tree = Node(t='expr')
                                    tree.AddChild(cond_tree)
                                    tree.Rename(op)
                                    tree.AddChild(expr_tree) 
                                 .) } .

  ReturnStatement<out tree>    = "VOZDAT"  [ Expression<out tree> ] ";" .

  WhileStatement<out tree>     = (. tree = Node(value='DOKOLE', t='key') .) "DOKOLE" 
                                 "(" Expression<out expr_tree> ")" Statement<out state_tree> 
                                 (. 
                                    expr_tree.Rename("condition")
                                    tree.AddChild(expr_tree)
                                    state_tree.Rename("statements")
                                    tree.AddChild(state_tree) 
                                 .) .

  IfStatement<out tree>        = (. tree = Node(value='KOLI', t='key') .) 
                                 "KOLI" "(" Expression<out expr_tree> ")" Statement<out state_tree> 
                                 (. 
                                    expr_tree.Rename("condition")
                                    tree.AddChild(expr_tree)
                                    state_tree.Rename("statements")
                                    tree.AddChild(state_tree)
                                 .)
                                 [ "OTNUD" Statement<out else_state_tree> 
                                 (.
                                    else_node = Node(value='OTNUD', t='key')
                                    else_node.AddChild(else_state_tree)
                                    tree.AddChild(else_node)
                                 .) ] .
  
  AssignmentExpression<out t>  = Expression<out t> ";" .

  Conditional<out tree>        = LogORExp<out tree>.

  LogORExp<out tree>           = LogANDExp<out and_tree_1> (. tree = and_tree_1 .)
                                 (. trees = [and_tree_1] .)
                                 { "ALI" LogANDExp<out and_tree_2> (. trees.append(and_tree_2) .)}
                                 (. 
                                    if (len(trees) > 1):
                                       tree = Node(value='ALI', t='expr')
                                       for tr in trees:
                                          tree.AddChild(tr)
                                 .) .

  LogANDExp<out tree>          = EqualExp<out eq_tree_1> (. tree = eq_tree_1 .)
                                 { "DA" EqualExp<out eq_tree_2> 
                                 (. 
                                    tree = Node(t='expr')
                                    tree.AddChild(eq_tree_1)
                                    tree.Rename('DA')
                                    tree.AddChild(eq_tree_2) 
                                 .) } .

  EqualExp<out tree>           = RelationExp<out rel_tree_1> (. tree = (rel_tree_1) .)
                                 { ( "==" ) RelationExp<out rel_tree_2> 
                                 (. 
                                    tree = Node(value='==', t='expr')
                                    tree.AddChild(rel_tree_1)
                                    tree.AddChild(rel_tree_2) 
                                 .) } .

  RelationExp<out tree>        = AddExp<out sub_tree_1> (. tree = sub_tree_1 .)
                                 { ( "<"  (. op  = '<' .)
                                 | ">"  (. op  = '>' .)
                                 | "<=" (. op  = '<=' .)
                                 | ">=" (. op  = '>=' .) ) 
                                 AddExp<out sub_tree_2> 
                                 (. 
                                    tree = Node(t='expr')
                                    tree.AddChild(sub_tree_1)
                                    tree.Rename(op)
                                    tree.AddChild(sub_tree_2) 
                                 .) }.

  AddExp<out tree>             = MultExp<out mult_tree_1> (. tree = mult_tree_1 .)
                                 (. trees = [mult_tree_1]; ops = [] .) 
                                 { ( "+" (. op = self.token.val .) 
                                 | "-" (. op = self.token.val .) ) 
                                 MultExp<out mult_tree_2> 
                                 (.
                                    ops.append(op)
                                    trees.append(mult_tree_2)
                                 .) } 
                                 (. 
                                    if len(trees) > 1:
                                       tree = Node(ops[0])
                                       tree.AddChild(trees[0])
                                       last = tree
                                       for i in range(1, len(trees) - 1):
                                          cur = Node(ops[i])
                                          cur.AddChild(trees[i])
                                          last.AddChild(cur)
                                          last = cur
                                       last.AddChild(trees[-1])
                                 .) .

  MultExp<out tree>            = CastExp<out cast_tree_1> (. tree =  cast_tree_1 .) 
                                 (. trees = [cast_tree_1]; ops = [] .)   
                                 { ( "*"  (. op = "*" .) 
                                 | "/"  (. op = "/" .)
                                 | "%"  (. op = "%" .) ) 
                                 CastExp<out cast_tree_2>
                                 (.
                                    ops.append(op)
                                    trees.append(cast_tree_2)
                                 .) } 
                                 (.
                                    if len(trees) > 1:
                                       tree = Node(ops[0])
                                       tree.AddChild(trees[0])
                                       last = tree
                                       for i in range(1, len(trees) - 1):
                                          cur = Node(ops[i])
                                          cur.AddChild(trees[i])
                                          last.AddChild(cur)
                                          last = cur
                                       last.AddChild(trees[-1]) 
                                 .) .

  CastExp<out tree>            = UnaryExp<out urary_tree> (. tree = urary_tree .) .

  UnaryExp<out tree>           = PostFixExp<out s> (. tree = s .)
                                 | UnaryOperator<out op> CastExp<out cast_tree>
                                 (.
                                    tree = Node()
                                    tree.Rename(op)
                                    tree.AddChild(cast_tree) 
                                 .) .

  PostFixExp<out tree>         = Primary<out child> (. tree = child; .)
                                 { "[" Expression<out expression_tree> "]" (. tree.AddChild(expression_tree) .)
                                 | FunctionCall<out f_call_tree>           (. tree = f_call_tree .) }.

  Primary<out prim>            = identifier   (. prim = Node(value=self.token.val, t='identifier') .) 
                                 | string     (. prim = Node(value=self.token.val, t='string') .) 
                                 | number     (. prim = Node(value=self.token.val, t='number') .) 
                                 | "(" Expression<out tree> ")" 
                                 (. 
                                    prim = Node(value="()", t='expr') 
                                    prim.AddChild(tree) 
                                 .) .

  FunctionCall<out res>        = (. res = Node(value=self.token.val, t='call') .)
                                 "(" [ ActualParameters<out expr> (. res.AddChild(expr) .) ] ")" .

  ActualParameters<out tree>   = (. tree = Node('params') .) 
                                 Expression<out expr> (. tree.AddChild(expr) .) 
                                 { "," Expression<out expr2> (. tree.AddChild(expr2) .) } .

  AssignmentOperator<out op>   =    "=" (. op = self.token.val .) 
                                 | "*=" (. op = self.token.val .)
                                 | "/=" (. op = self.token.val .)
                                 | "%=" (. op = self.token.val .)
                                 | "+=" (. op = self.token.val .) .

  UnaryOperator<out op>        =   "+"  (. op = self.token.val .) 
                                 | "-"  (. op = self.token.val .) 
                                 | "*"  (. op = self.token.val .) 
                                 | "NE" (. op = self.token.val .) .

END VeKrestKrest.
